use std::sync::{Arc, Mutex, SystemTime, UNIX_EPOCH};

/// The index of an actor in the VVM.
pub type Address = u32;

/// Addresses of important root services.
pub const PERM_ADDR: Address = 1;
pub const ALLOCATOR_ADDR: Address = 2;
pub const LOGGER_ADDR: Address = 3;

/// Addresses of implementations of important root services
pub const LOGGER_IMPL_ADDR: Address = 4;
pub const ALLOCATOR_IMPL_ADDR: Address = 5;
pub const DOM_ADDR: Address = 6;
pub const DISPLAY_MANAGER_ADDR: Address = 7;
pub const MOCK_ALLOCATOR_ADDR: Address = 8;
pub const FETCH_ADDR: Address = 9;

/// Failure utilities
pub const EXIT_SUCCESS: u32 = 0;
pub const EXIT_FAILURE: u32 = 1;

/// Supplied to message bindings created by with_bindings to capture the
/// value generated by the handling actor.
pub struct Callback<T>(
	Arc<Mutex<Option<Box<dyn FnOnce(T) + Send + Sync>>>>,
	pub usize,
);

impl<T> Callback<T> {
	pub fn new(cb: impl FnOnce(T) + Send + Sync + 'static) -> Self {
		let t = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();

		Self(Arc::new(Mutex::new(Some(Box::new(cb)))), t)
	}

	pub fn call(self, arg: T) {
		if let Some(cb) = self.0.lock().ok().and_then(|mut lock| lock.take()) {
			cb(arg)
		}
	}
}
